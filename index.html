<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Vision Board ‚Äî MTA (Neon) v2</title>

<!-- Tipograf√≠a -->
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

<!-- html2canvas para exportaci√≥n -->
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

<style>
  :root{
    --bg:#050505;
    --panel:#070707;
    --muted:#9fbfb2;
    --neon-violet: #aa00ff;
    --neon-green:  #4cfc0f;
    --neon-orange: #ff9100;
    --glass: rgba(255,255,255,0.02);
    --card-radius: 14px;
  }

  html,body{height:100%;margin:0;background:linear-gradient(180deg,#000,#050505);font-family:Inter,Arial,sans-serif;color:#eafaf0;overflow:hidden}
  .wrap{box-sizing:border-box;max-width:1500px;margin:18px auto;padding:14px}
  header{display:flex;gap:12px;align-items:center;margin-bottom:12px}
  .logo{width:56px;height:56px;border-radius:12px;display:flex;align-items:center;justify-content:center;font-weight:800;color:#021013;background: linear-gradient(135deg, rgba(76,252,15,0.06), rgba(170,0,255,0.05));}
  h1{margin:0;font-family:Cinzel,serif;color:var(--neon-green)}
  p.lead{margin:4px 0 0;color:var(--muted);font-size:13px}

  /* toolbar */
  .toolbar{display:flex;gap:8px;align-items:center;margin:12px 0;flex-wrap:wrap}
  .btn{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:8px 12px;border-radius:10px;color:var(--muted);cursor:pointer;user-select:none}
  .btn:hover{transform:translateY(-2px);box-shadow:0 8px 28px rgba(0,0,0,0.6)}
  .btn.primary{border-color:var(--neon-violet);color:var(--neon-violet);box-shadow:0 8px 40px rgba(170,0,255,0.06)}
  .toolbar .controls{margin-left:auto;display:flex;gap:8px;align-items:center}

  /* active states (neon) */
  .btn.active { color: var(--neon-violet); border-color: var(--neon-violet); box-shadow: 0 0 18px var(--neon-violet), inset 0 0 10px rgba(170,0,255,0.06); }
  .btn.active.delete { color: #ff6b6b; border-color: #ff6b6b; box-shadow: 0 0 18px #ff6b6b, inset 0 0 10px rgba(255,107,107,0.06); }
  .btn.active.connect { color: var(--neon-green); border-color: var(--neon-green); box-shadow: 0 0 18px var(--neon-green), inset 0 0 10px rgba(76,252,15,0.06); }

  /* board */
  .board-wrap{display:flex;gap:12px}
  .board {
    flex:1;
    height:70vh;
    min-height:420px;
    background: linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.006));
    border-radius:var(--card-radius);
    border:1px solid rgba(255,255,255,0.03);
    position:relative;
    overflow:hidden;
    box-shadow: 0 40px 120px rgba(0,0,0,0.7);
    touch-action:none;
  }

  /* wrap inside board ‚Äî we'll scale this for zoom */
  .board-inner { position:absolute; inset:0; transform-origin: 0 0; }

  /* Left control panel */
  .side-panel{
    width:320px;
    max-width:32%;
    min-width:240px;
    background: linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.006));
    border-radius:12px;
    padding:12px;
    box-sizing:border-box;
    border:1px solid rgba(255,255,255,0.03);
    display:flex;
    flex-direction:column;
    gap:10px;
  }
  .side-panel h3{margin:0;color:var(--muted);font-size:14px}
  .control-row{display:flex;gap:8px;align-items:center}
  .color-swatch{width:34px;height:34px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);cursor:pointer}
  .small{font-size:13px;color:var(--muted)}

  /* SVG overlay for connections */
  svg.links{position:absolute;inset:0;width:100%;height:100%;pointer-events:none;z-index:6;overflow:visible}

  /* nodes */
  .nodes {position:absolute;inset:0;z-index:8}
  .node{
    position:absolute;
    min-width:140px;
    max-width:520px;
    background: rgba(12,12,12,0.90);
    border-radius:12px;
    padding:10px;
    color:#fff;
    border:1px solid rgba(255,255,255,0.04);
    box-shadow: 0 12px 40px rgba(0,0,0,0.7);
    cursor:grab;
    user-select:none;
    display:flex;
    flex-direction:column;
    gap:8px;
    z-index:12;
    touch-action:none;
    transition:transform .12s;
    box-sizing:border-box;
  }
  .node:active{cursor:grabbing}
  .node .title{font-weight:700;font-size:1rem;color:var(--neon-green)}
  .node .content{font-size:0.92rem;color:#dfffdc;white-space:pre-wrap}
  .node img{max-width:100%;border-radius:8px;display:block}
  .node .actions{display:flex;gap:6px;justify-content:flex-end}
  .tiny{font-size:12px;padding:6px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.03);color:var(--muted);cursor:pointer}

  /* resize handle */
  .node .resize-handle{
    position:absolute;
    width:12px;
    height:12px;
    border-radius:50%;
    background: rgba(170,0,255,0.9);
    box-shadow: 0 0 6px rgba(170,0,255,0.6);
    z-index:20;
    border:2px solid rgba(255,255,255,0.3);
    opacity:0;
    transition:opacity 0.15s ease;
  }
  .node:hover .resize-handle,
  .node.selected .resize-handle {
    opacity:1;
  }

  /* selected nodos (multiselect) */
  .node.selected { box-shadow: 0 0 28px rgba(76,252,15,0.12), inset 0 0 8px rgba(76,252,15,0.03); border-color: rgba(76,252,15,0.12); }

  /* selection rectangle */
  .selection-rect{ position:absolute; border:2px dashed rgba(170,0,255,0.5); background:rgba(170,0,255,0.06); pointer-events:none; z-index:130 }

  /* neon glow wrapper for selection text */
  .neon-wrap{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:7;pointer-events:none}
  .neon-box{
    pointer-events:none;
    border-radius:20px;
    padding:10px 18px;
    color:transparent;
    box-sizing:border-box;
    max-width:90%;
  }
  .neon-box::before{
    content:"";
    position:absolute;inset:0;border-radius:inherit;z-index:-1;
    background: rgba(255,255,255,0.02);
    box-shadow: 0 0 30px var(--neon-violet), 0 0 60px rgba(170,0,255,0.08), inset 0 0 12px rgba(170,0,255,0.06);
    opacity:0;
    transition:opacity .28s;
  }
  .neon-active .neon-box::before{opacity:1}

  /* grid */
  .grid {position:absolute;inset:0;pointer-events:none;z-index:3}
  .grid .line{stroke:rgba(255,255,255,0.02);stroke-width:1}

  /* pulsing animation for links */
  @keyframes linkPulse {
    0% { stroke-opacity: 0.7; filter: drop-shadow(0 0 6px rgba(170,0,255,0.08)); stroke-width:2.2; }
    50% { stroke-opacity: 1; filter: drop-shadow(0 0 18px rgba(170,0,255,0.28)); stroke-width:3.4; }
    100% { stroke-opacity: 0.7; filter: drop-shadow(0 0 6px rgba(170,0,255,0.08)); stroke-width:2.2; }
  }
  .link-anim { animation: linkPulse 1.6s ease-in-out infinite; }

  /* full modal */
  .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.7);z-index:140}
  .modal.open{display:flex}
  .modal .card{background:#070707;border:1px solid rgba(255,255,255,0.03);padding:18px;border-radius:12px;color:var(--muted);max-width:760px;width:92%}

  /* responsiveness */
  @media (max-width:1000px){
    .board-wrap{flex-direction:column}
    .side-panel{width:100%;max-width:none;min-width:unset;order:2}
    .board{order:1;height:56vh}
  }

  /* small helpers */
  .muted{color:var(--muted);font-size:13px}
  input[type="range"]{width:100%}
  .flex{display:flex;gap:8px;align-items:center}
</style>
</head>
<body>

<div class="wrap" role="application" aria-label="Vision Board MTA">

  <header>
    <div class="logo">MTA</div>
    <div>
      <h1>Vision Board</h1>
      <p class="lead">Pizarra interactiva ‚Äî arrastr√°, conect√°, sub√≠ im√°genes y guard√° tu progreso.</p>
    </div>
  </header>

  <div class="toolbar">
    <button class="btn" id="addText">+ Texto</button>
    <button class="btn" id="addImage">+ Imagen (ejemplo)</button>
    <label class="btn">
      <input type="file" id="uploadFile" accept="image/*" style="display:none">
      Subir imagen
    </label>
    <button class="btn" id="connectMode">Conectar</button>
    <button class="btn" id="deleteMode">Borrar</button>
    <button class="btn" id="clearAll">Limpiar</button>

    <div class="controls">
      <button class="btn primary" id="saveBtn">Guardar</button>
      <button class="btn" id="loadBtn">Cargar</button>
      <button class="btn" id="exportJsonBtn">Exportar JSON</button>
      <button class="btn" id="exportImageBtn">Exportar PNG</button>
      <button class="btn" id="importBtn">Importar</button>
    </div>
  </div>

  <div class="board-wrap">
    <!-- board -->
    <div class="board" id="board" tabindex="0" aria-label="Pizarra de visi√≥n">
      <div class="board-inner" id="boardInner">
        <svg class="grid" id="gridSvg" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg"></svg>
        <svg class="links" id="linksSvg" xmlns="http://www.w3.org/2000/svg"></svg>
        <div class="nodes" id="nodes"></div>
      </div>

      <div class="neon-wrap" id="neonWrap">
        <div class="neon-box" id="neonBox"></div>
      </div>
      <!-- selection rect -->
      <div id="selectionRect" class="selection-rect" style="display:none"></div>
    </div>

    <!-- side panel -->
    <aside class="side-panel" aria-label="Panel de configuraci√≥n">
      <h3>Personalizaci√≥n</h3>
      <div class="control-row">
        <div class="small">Color flechas</div>
      </div>
      <div class="control-row">
        <div class="color-swatch" id="violetSw" style="background:var(--neon-violet)"></div>
        <div class="color-swatch" id="greenSw" style="background:var(--neon-green)"></div>
      </div>

      <div class="control-row">
        <div class="small">Mostrar grid</div>
        <label style="margin-left:auto"><input type="checkbox" id="toggleGrid" checked></label>
      </div>

      <div class="control-row">
        <div class="small">Snap a grid</div>
        <label style="margin-left:auto"><input type="checkbox" id="toggleSnap"></label>
      </div>

      <div>
        <div class="small">Tama√±o nodos (m√≠n-max)</div>
        <input id="minW" type="range" min="100" max="220" value="140">
        <input id="maxW" type="range" min="240" max="520" value="360">
      </div>

      <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03)">

      <div style="display:flex;gap:8px;align-items:center">
        <button class="btn" id="undoBtn">Deshacer</button>
        <button class="btn" id="redoBtn">Rehacer</button>
      </div>

      <div style="margin-top:auto">
        <div class="muted">Tips:</div>
        <ul style="margin:6px 0 0;padding-left:16px;color:var(--muted);font-size:13px">
          <li>Dobleclic en t√≠tulo o contenido para editar (no abre explorador)</li>
          <li>Arrastr√° para mover</li>
          <li>Click conectar: luego clic en dos nodos</li>
          <li>Ctrl/Cmd + Click para selecci√≥n m√∫ltiple; arrastra para selecci√≥n tambi√©n</li>
          <li>Ctrl/Cmd + D para duplicar nodos seleccionados</li>
        </ul>
      </div>
    </aside>
  </div>
</div>

<!-- modal import -->
<div class="modal" id="importModal" role="dialog" aria-hidden="true">
  <div class="card">
    <h3>Importar JSON</h3>
    <textarea id="importArea" style="width:100%;height:180px;background:#060606;color:#eafaf0;border-radius:8px;padding:8px;border:1px solid rgba(255,255,255,0.03)"></textarea>
    <div style="margin-top:10px;display:flex;gap:8px;justify-content:flex-end">
      <button class="btn" id="doImport">Importar</button>
      <button class="btn" id="closeImport">Cerrar</button>
    </div>
  </div>
</div>

<script>
/* Vision Board MTA - v3 integrated features:
   - resize handles (remember w/h)
   - zoom with scroll (wheel)
   - multi-select (ctrl/cmd + click) and drag selection
   - duplicate nodes (Ctrl/Cmd + D)
   - export PNG transparent with faded watermark
   - connect/delete working + neon active UI
*/

/* ----------------- UTIL ----------------- */
const $ = sel => document.querySelector(sel);
const $$ = sel => Array.from(document.querySelectorAll(sel));

/* ----------------- ELEMENTS ----------------- */
const board = $('#board');
const boardInner = $('#boardInner');
const nodesEl = $('#nodes');
const linksSvg = $('#linksSvg');
const gridSvg = $('#gridSvg');
const neonWrap = $('#neonWrap');
const neonBox = $('#neonBox');
const selectionRect = $('#selectionRect');

const addTextBtn = $('#addText');
const addImageBtn = $('#addImage');
const uploadFile = $('#uploadFile');
const connectModeBtn = $('#connectMode');
const deleteModeBtn = $('#deleteMode');
const clearAllBtn = $('#clearAll');
const saveBtn = $('#saveBtn');
const loadBtn = $('#loadBtn');
const exportJsonBtn = $('#exportJsonBtn');
const exportImageBtn = $('#exportImageBtn');
const importBtn = $('#importBtn');
const importModal = $('#importModal');
const importArea = $('#importArea');
const doImportBtn = $('#doImport');
const closeImportBtn = $('#closeImport');

const violetSw = $('#violetSw');
const greenSw = $('#greenSw');
const toggleGrid = $('#toggleGrid');
const toggleSnap = $('#toggleSnap');
const minWControl = $('#minW');
const maxWControl = $('#maxW');
const undoBtn = $('#undoBtn');
const redoBtn = $('#redoBtn');

/* ----------------- STATE ----------------- */
let state = { nodes: [], links: [] };
let historyStack = [], redoStack = [];
let mode = null; // null | 'connect' | 'delete'
let connectFrom = null;
let dragging = null;
let idc = 1;
let scale = 1;
let selectedIds = new Set();
let isSelecting = false;
let selectStart = null;

let config = {
  linkColor: getComputedStyle(document.documentElement).getPropertyValue('--neon-violet').trim() || '#aa00ff',
  neonActive: false,
  snap: false,
  gridSize: 24,
  minW: parseInt(minWControl.value),
  maxW: parseInt(maxWControl.value)
};

/* ----------------- HELPERS ----------------- */
function uid(prefix='n'){ return prefix + (Date.now().toString(36).slice(-6)) + Math.floor(Math.random()*999).toString(36); }

function pushHistory(){
  historyStack.push(JSON.stringify(state));
  if(historyStack.length>60) historyStack.shift();
  redoStack = [];
}
function undo(){ if(historyStack.length>1){ redoStack.push(historyStack.pop()); const prev = historyStack[historyStack.length-1]; loadState(JSON.parse(prev), false); } }
function redo(){ if(redoStack.length){ const v = redoStack.pop(); historyStack.push(v); loadState(JSON.parse(v), false); } }
undoBtn.addEventListener('click', undo);
redoBtn.addEventListener('click', redo);

/* ----------------- GRID ----------------- */
function drawGrid(){
  while(gridSvg.firstChild) gridSvg.removeChild(gridSvg.firstChild);
  if(!toggleGrid.checked) return;
  const w = board.clientWidth, h = board.clientHeight;
  const g = config.gridSize;
  for(let x=0;x<w;x+=g){
    const ln = document.createElementNS('http://www.w3.org/2000/svg','line');
    ln.setAttribute('x1',x); ln.setAttribute('y1',0); ln.setAttribute('x2',x); ln.setAttribute('y2',h);
    ln.setAttribute('class','line');
    ln.setAttribute('stroke','rgba(255,255,255,0.02)');
    gridSvg.appendChild(ln);
  }
  for(let y=0;y<h;y+=g){
    const ln = document.createElementNS('http://www.w3.org/2000/svg','line');
    ln.setAttribute('x1',0); ln.setAttribute('y1',y); ln.setAttribute('x2',w); ln.setAttribute('y2',y);
    ln.setAttribute('class','line');
    ln.setAttribute('stroke','rgba(255,255,255,0.02)');
    gridSvg.appendChild(ln);
  }
}

/* ----------------- RENDER LINKS ----------------- */
function redrawLinks(){
  while(linksSvg.firstChild) linksSvg.removeChild(linksSvg.firstChild);
  if(!state.links) state.links=[];
  // defs arrow
  const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
  const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');
  marker.setAttribute('id','arr'); marker.setAttribute('markerWidth','10'); marker.setAttribute('markerHeight','10');
  marker.setAttribute('refX','6'); marker.setAttribute('refY','5'); marker.setAttribute('orient','auto');
  const pathM = document.createElementNS('http://www.w3.org/2000/svg','path');
  pathM.setAttribute('d','M0,0 L10,5 L0,10 z');
  pathM.setAttribute('fill', config.linkColor);
  marker.appendChild(pathM);
  defs.appendChild(marker);
  linksSvg.appendChild(defs);

  state.links.forEach(l=>{
    const n1 = state.nodes.find(n=>n.id===l.from);
    const n2 = state.nodes.find(n=>n.id===l.to);
    if(!n1 || !n2) return;
    const el1 = nodesEl.querySelector(`[data-id="${n1.id}"]`);
    const el2 = nodesEl.querySelector(`[data-id="${n2.id}"]`);
    if(!el1 || !el2) return;
    const r1 = el1.getBoundingClientRect(), r2 = el2.getBoundingClientRect();
    const br = board.getBoundingClientRect();
    const x1 = r1.left - br.left + r1.width/2;
    const y1 = r1.top - br.top + r1.height/2;
    const x2 = r2.left - br.left + r2.width/2;
    const y2 = r2.top - br.top + r2.height/2;
    const dx = Math.abs(x2-x1);
    const cx1 = x1 + dx*0.28, cy1 = y1;
    const cx2 = x2 - dx*0.28, cy2 = y2;
    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    path.setAttribute('d', `M ${x1} ${y1} C ${cx1} ${cy1} ${cx2} ${cy2} ${x2} ${y2}`);
    path.setAttribute('stroke', config.linkColor);
    path.setAttribute('stroke-width','2.6');
    path.setAttribute('fill','none');
    path.setAttribute('marker-end','url(#arr)');
    path.setAttribute('class','link-anim');
    path.style.filter = `drop-shadow(0 0 10px ${config.linkColor}33)`;
    linksSvg.appendChild(path);
  });
}

let resizing = null;

/* ----------------- NODE DOM ----------------- */
function createNodeDOM(n){
  const el = document.createElement('div');
  el.className = 'node';
  el.dataset.id = n.id;
  el.style.left = (n.x)+'px';
  el.style.top = (n.y)+'px';
  // apply saved size or defaults
  el.style.width = (n.w || config.minW) + 'px';
  el.style.height = (n.h || 100) + 'px';
  el.style.minWidth = config.minW + 'px';
  el.style.maxWidth = config.maxW + 'px';

  // title content
  const title = document.createElement('div'); title.className = 'title'; title.contentEditable = false; title.innerText = n.title || 'Nueva meta';
  title.addEventListener('input', ()=> { n.title = title.innerText; scheduleSave(); });

  const content = document.createElement('div'); content.className = 'content'; content.contentEditable = false; content.innerText = n.content || '';
  content.addEventListener('input', ()=> { n.content = content.innerText; scheduleSave(); });

  el.appendChild(title);

  if(n.img){
    const img = document.createElement('img');
    img.src = n.img;
    img.alt = n.title || 'imagen';
    el.appendChild(img);
  }

  el.appendChild(content);

  const actions = document.createElement('div'); actions.className='actions';
  const btnConnect = document.createElement('button'); btnConnect.className='tiny'; btnConnect.innerText='‚áÑ'; btnConnect.title='Conectar r√°pido';
  const btnDelete = document.createElement('button'); btnDelete.className='tiny'; btnDelete.innerText='üóë'; btnDelete.title='Eliminar';
  actions.appendChild(btnConnect); actions.appendChild(btnDelete);
  el.appendChild(actions);

  // resize handles
  const types = ['nw','ne','sw','se'];
  types.forEach(type => {
    const handle = document.createElement('div');
    handle.classList.add('resize-handle', type);
    handle.dataset.type = type;
    switch(type){
      case 'nw':
        handle.style.top = '-6px';
        handle.style.left = '-6px';
        handle.style.cursor = 'nw-resize';
        break;
      case 'ne':
        handle.style.top = '-6px';
        handle.style.right = '-6px';
        handle.style.cursor = 'ne-resize';
        break;
      case 'sw':
        handle.style.bottom = '-6px';
        handle.style.left = '-6px';
        handle.style.cursor = 'sw-resize';
        break;
      case 'se':
        handle.style.bottom = '-6px';
        handle.style.right = '-6px';
        handle.style.cursor = 'se-resize';
        break;
    }
    el.appendChild(handle);
  });

  // events for action buttons
  btnConnect.addEventListener('click', (e)=>{ e.stopPropagation(); toggleMode('connect'); connectFrom = n.id; highlightNode(n.id); updateButtonsUI(); });
  btnDelete.addEventListener('click', (e)=>{ e.stopPropagation(); removeNode(n.id); });

  // dragging (pointer) and resizing
  el.addEventListener('pointerdown', (e)=>{
    if(mode==='delete'){ removeNode(n.id); return; }

    // check if on resize handle
    if(e.target !== el && e.target.classList.contains('resize-handle')){
      const handleType = e.target.dataset.type;
      resizing = {
        id: n.id,
        handleType,
        startX: e.clientX,
        startY: e.clientY,
        startW: el.offsetWidth,
        startH: el.offsetHeight,
        startLeft: parseFloat(el.style.left) || 0,
        startTop: parseFloat(el.style.top) || 0,
        handle: e.target
      };
      try { e.target.setPointerCapture(e.pointerId); } catch (err) {}
      return;
    }

    // selection logic
    if(e.ctrlKey || e.metaKey){
      toggleSelection(n.id);
      e.stopPropagation();
      return;
    } else {
      if(!selectedIds.has(n.id)){
        clearSelection();
        setSelected(n.id, true);
      }
    }

    // start dragging: capture mouse and record start info
    // record start client coords and, for each selected node, its start position
    const selectedArray = Array.from(selectedIds);
    const startInfo = {};
    selectedArray.forEach(id => {
      const nodeState = state.nodes.find(nn => nn.id === id);
      startInfo[id] = { x: nodeState.x, y: nodeState.y };
    });

    dragging = {
      el,
      id: n.id,
      startClientX: e.clientX,
      startClientY: e.clientY,
      startPositions: startInfo,
      selectedArray
    };

    try { el.setPointerCapture(e.pointerId); } catch (err) {}
    el.style.transition = 'none';
  });
  el.addEventListener('pointermove', (e)=>{
    if(!dragging || dragging.id !== n.id) return;

    // compute delta in board coordinate space (adjust for current scale)
    const dx = (e.clientX - dragging.startClientX) / (scale || 1);
    const dy = (e.clientY - dragging.startClientY) / (scale || 1);

    // move each selected node relative to its start position (no accumulation)
    dragging.selectedArray.forEach(id => {
      const nodeState = state.nodes.find(nn => nn.id === id);
      const dom = nodesEl.querySelector(`[data-id="${id}"]`);
      if(!nodeState || !dom) return;
      const startPos = dragging.startPositions[id];
      const nx = startPos.x + dx;
      const ny = startPos.y + dy;

      // optional: keep nodes visually within board while dragging (soft constrain)
      const margin = 6 / scale;
      const coordBoardW = board.clientWidth / scale;
      const coordBoardH = board.clientHeight / scale;
      const coordNodeW = dom.offsetWidth / scale;
      const coordNodeH = dom.offsetHeight / scale;
      const clampedX = Math.max(margin, Math.min(coordBoardW - coordNodeW - margin, nx));
      const clampedY = Math.max(margin, Math.min(coordBoardH - coordNodeH - margin, ny));

      dom.style.left = clampedX + 'px';
      dom.style.top = clampedY + 'px';
      nodeState.x = clampedX;
      nodeState.y = clampedY;
    });

    redrawLinks();
  });
  el.addEventListener('pointerup', (e)=>{
    if(!dragging) return;
    try { dragging.el.releasePointerCapture(e.pointerId); } catch(e){}
    dragging = null;
    el.style.transition='';

    // apply snap at drop
    if(config.snap && toggleGrid.checked){
      selectedIds.forEach(id => {
        const nodeState = state.nodes.find(nn=>nn.id===id);
        const dom = nodesEl.querySelector(`[data-id="${id}"]`);
        if(!nodeState || !dom) return;
        nodeState.x = Math.round(nodeState.x / config.gridSize) * config.gridSize;
        nodeState.y = Math.round(nodeState.y / config.gridSize) * config.gridSize;
        dom.style.left = nodeState.x + 'px';
        dom.style.top = nodeState.y + 'px';
      });
    }

    // constrain to board bounds
    selectedIds.forEach(id => {
      const nodeState = state.nodes.find(nn=>nn.id===id);
      const dom = nodesEl.querySelector(`[data-id="${id}"]`);
      if(!nodeState || !dom) return;
      const visualMargin = 6;
      const coordBoardW = board.clientWidth / scale;
      const coordBoardH = board.clientHeight / scale;
      const coordNodeW = dom.offsetWidth / scale;
      const coordNodeH = dom.offsetHeight / scale;
      nodeState.x = Math.max(visualMargin / scale, Math.min(coordBoardW - coordNodeW - visualMargin / scale, nodeState.x));
      nodeState.y = Math.max(visualMargin / scale, Math.min(coordBoardH - coordNodeH - visualMargin / scale, nodeState.y));
      dom.style.left = nodeState.x + 'px';
      dom.style.top = nodeState.y + 'px';
    });

    pushHistory();
    scheduleSaveImmediate();
  });

  // click behavior (single click)
  el.addEventListener('click', (e)=>{
    e.stopPropagation();
    if(mode==='connect'){
      if(!connectFrom){ connectFrom = n.id; highlightNode(n.id); }
      else if(connectFrom===n.id){ connectFrom=null; clearHighlights(); }
      else { addLink(connectFrom, n.id); connectFrom=null; clearHighlights(); }
    } else {
      // selection when clicking (without ctrl)
      if(! (e.ctrlKey || e.metaKey) ){
        clearSelection();
        setSelected(n.id, true);
      }
    }
  });

  // dblclick toggles contentEditable (no file explorer)
  el.addEventListener('dblclick', (e)=>{
    e.stopPropagation();
    const currentlyEditable = title.contentEditable === 'true' || content.contentEditable === 'true';
    title.contentEditable = currentlyEditable ? 'false' : 'true';
    content.contentEditable = currentlyEditable ? 'false' : 'true';
    if(!currentlyEditable){
      title.focus();
      document.execCommand('selectAll', false, null);
    } else {
      n.title = title.innerText;
      n.content = content.innerText;
      scheduleSave();
    }
  });

  el.addEventListener('pointermove', (ev)=>{
    if(!resizing) return;
    let newW = resizing.startW;
    let newH = resizing.startH;
    let newLeft = resizing.startLeft;
    let newTop = resizing.startTop;
    const dx = ev.clientX - resizing.startX;
    const dy = ev.clientY - resizing.startY;
    const aspect = resizing.startH / (resizing.startW || 1);
    switch(resizing.handleType){
      case 'nw':
        newW = Math.max(config.minW, resizing.startW - dx);
        newH = aspect * newW;
        newLeft = resizing.startLeft + (resizing.startW - newW);
        newTop = resizing.startTop + (resizing.startH - newH);
        break;
      case 'ne':
        newW = Math.max(config.minW, resizing.startW + dx);
        newH = aspect * newW;
        newTop = resizing.startTop + (resizing.startH - newH);
        break;
      case 'se':
        newW = Math.max(config.minW, resizing.startW + dx);
        newH = aspect * newW;
        break;
      case 'sw':
        newW = Math.max(config.minW, resizing.startW - dx);
        newH = aspect * newW;
        newLeft = resizing.startLeft + (resizing.startW - newW);
        break;
    }
    el.style.width = newW + 'px';
    el.style.height = newH + 'px';
    el.style.left = newLeft + 'px';
    el.style.top = newTop + 'px';
    const nodeState = state.nodes.find(nn=>nn.id===resizing.id);
    if(nodeState){ nodeState.w = newW; nodeState.h = newH; nodeState.x = newLeft; nodeState.y = newTop; }
    redrawLinks();
  });
  el.addEventListener('pointerup', (ev)=>{
    if(!resizing) return;
    try { resizing.handle.releasePointerCapture(ev.pointerId); } catch(err){}
    resizing = null;
    pushHistory();
    scheduleSaveImmediate();
    redrawLinks();
  });

  return el;
}

/* ----------------- CRUD nodes ----------------- */
function addNode(opts = {}){
  const n = Object.assign({
    id: uid('n'),
    x: 40 + Math.random()*200,
    y: 40 + Math.random()*120,
    w: opts.w || config.minW,
    h: opts.h || 100,
    title: opts.title || 'Nueva Meta',
    content: opts.content || '',
    img: opts.img || null
  }, opts);
  state.nodes.push(n);
  const dom = createNodeDOM(n);
  nodesEl.appendChild(dom);
  pushHistory();
  scheduleSave();
  redrawLinks();
  return n;
}

function addImageNodeFromDataUrl(dataUrl){
  addNode({title:'Imagen', img: dataUrl, w:240, h:140});
}

function removeNode(id){
  state.nodes = state.nodes.filter(n => n.id !== id);
  state.links = state.links.filter(l => l.from !== id && l.to !== id);
  const el = nodesEl.querySelector(`[data-id="${id}"]`);
  if(el) el.remove();
  selectedIds.delete(id);
  pushHistory();
  scheduleSave();
  redrawLinks();
}

function addLink(a,b){
  if(a===b) return;
  if(state.links.some(l=> (l.from===a && l.to===b) || (l.from===b && l.to===a))) return;
  state.links.push({id: uid('l'), from:a, to:b});
  pushHistory();
  scheduleSave();
  redrawLinks();
}

/* ----------------- SELECTION HELPERS ----------------- */
function setSelected(id, on=true){
  const el = nodesEl.querySelector(`[data-id="${id}"]`);
  if(on){ selectedIds.add(id); if(el) el.classList.add('selected'); }
  else { selectedIds.delete(id); if(el) el.classList.remove('selected'); }
}
function clearSelection(){
  selectedIds.forEach(id=>{
    const el = nodesEl.querySelector(`[data-id="${id}"]`);
    if(el) el.classList.remove('selected');
  });
  selectedIds.clear();
}
function toggleSelection(id){
  if(selectedIds.has(id)) setSelected(id,false);
  else setSelected(id,true);
}

/* ----------------- UI helpers ----------------- */
function clearHighlights(){ Array.from(nodesEl.children).forEach(n=> n.style.boxShadow=''); }
function highlightNode(id){ clearHighlights(); const el = nodesEl.querySelector(`[data-id="${id}"]`); if(el) el.style.boxShadow = `0 0 28px ${config.linkColor}33`; }

function updateButtonsUI(){
  connectModeBtn.classList.toggle('active', mode==='connect');
  connectModeBtn.classList.toggle('connect', mode==='connect');
  deleteModeBtn.classList.toggle('active', mode==='delete');
  deleteModeBtn.classList.toggle('delete', mode==='delete');
}

/* ----------------- SAVE / LOAD / EXPORT ----------------- */
function scheduleSave(){
  if(window._saveTimer) clearTimeout(window._saveTimer);
  window._saveTimer = setTimeout(()=> {
    try{ localStorage.setItem('visionboard_v3', JSON.stringify(state)); }catch(e){ console.warn(e); }
  }, 400);
}
function scheduleSaveImmediate(){
  if(window._saveTimer) clearTimeout(window._saveTimer);
  window._saveTimer = setTimeout(()=> {
    try{ localStorage.setItem('visionboard_v3', JSON.stringify(state)); }catch(e){ console.warn(e); }
  }, 80);
}

function saveToLocal(){
  try{ localStorage.setItem('visionboard_v3', JSON.stringify(state)); showNeon('Guardado local'); }catch(e){ alert('Error guardando'); }
}
function loadFromLocal(){
  const raw = localStorage.getItem('visionboard_v3');
  if(!raw){ alert('No hay guardado'); return; }
  try{ const parsed = JSON.parse(raw); loadState(parsed, true); showNeon('Cargado local'); }catch(e){ alert('Error al cargar'); }
}

function exportJSON(){
  const data = JSON.stringify(state, null, 2);
  const blob = new Blob([data], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'visionboard.json'; a.click();
  URL.revokeObjectURL(url);
}

/* Export board as PNG transparent with watermark behind */
async function exportBoardAsPNG(){
  // watermark image (you provided Imgur)
  const watermarkUrl = 'https://imgur.com/5kcUsNT';
  const imgW = await loadImage(watermarkUrl).catch(()=>null);

  // capture board inner (nodes + links) with transparent background
  const options = { backgroundColor: null, useCORS: true, scale: Math.min(2, window.devicePixelRatio || 1) };
  const canvasSnapshot = await html2canvas(boardInner, options);

  // final canvas
  const w = canvasSnapshot.width;
  const h = canvasSnapshot.height;
  const final = document.createElement('canvas');
  final.width = w; final.height = h;
  const ctx = final.getContext('2d');

  // draw watermark faint behind
  if(imgW){
    ctx.globalAlpha = 0.12;
    ctx.drawImage(imgW, 0, 0, w, h);
    ctx.globalAlpha = 1;
  }

  // draw snapshot on top
  ctx.drawImage(canvasSnapshot, 0, 0);

  // download
  const a = document.createElement('a');
  a.href = final.toDataURL('image/png');
  a.download = 'visionboard.png';
  a.click();
}

/* helper to load image */
function loadImage(src){
  return new Promise((res, rej)=>{
    const i = new Image();
    i.crossOrigin = "anonymous";
    i.onload = () => res(i);
    i.onerror = (e) => rej(e);
    i.src = src;
  });
}

/* ----------------- IMPORT / UI ----------------- */
function openImport(){
  importModal.classList.add('open'); importModal.setAttribute('aria-hidden','false');
  importArea.value = '';
}
function closeImport(){ importModal.classList.remove('open'); importModal.setAttribute('aria-hidden','true'); }

function doImport(){
  try{
    const parsed = JSON.parse(importArea.value);
    loadState(parsed, true);
    closeImport();
    showNeon('Importado OK');
  }catch(e){ alert('JSON inv√°lido'); }
}
importBtn.addEventListener('click', openImport);
doImportBtn.addEventListener('click', doImport);
closeImportBtn.addEventListener('click', closeImport);

/* ----------------- LOAD / RENDER ----------------- */
function loadState(s, pushHistory=true){
  state = s || {nodes:[], links:[]};
  nodesEl.innerHTML = '';
  (state.nodes||[]).forEach(n=> {
    const dom = createNodeDOM(n);
    nodesEl.appendChild(dom);
  });
  redrawLinks();
  drawGrid();
  if(pushHistory) { pushHistory(); }
}

function initialState(){
  addNode({x:30,y:40,title:'Meta Principal',content:'Lograr autonom√≠a financiera en 2 a√±os', w:260, h:110});
  addNode({x:260,y:60,title:'Hito: Cursos',content:'Completar formaci√≥n de psicotrading', w:220, h:100});
  addNode({x:140,y:240,title:'Rutina',content:'Meditaci√≥n + Checklist pre-market', w:200, h:100});
  pushHistory();
}

/* ----------------- EVENTS ----------------- */
addTextBtn.addEventListener('click', ()=> addNode());
addImageBtn.addEventListener('click', ()=> {
  // sample image (small placeholder)
  const sample = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA...'; // replace if needed
  addImageNodeFromDataUrl(sample);
});
uploadFile.addEventListener('change', (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  const reader = new FileReader();
  reader.onload = (ev)=> addImageNodeFromDataUrl(ev.target.result);
  reader.readAsDataURL(f);
});

connectModeBtn.addEventListener('click', ()=> { toggleMode('connect'); updateButtonsUI(); });
deleteModeBtn.addEventListener('click', ()=> { toggleMode('delete'); updateButtonsUI(); });
clearAllBtn.addEventListener('click', ()=>{ if(!confirm('Borrar todo?')) return; state = {nodes:[], links:[]}; nodesEl.innerHTML=''; redrawLinks(); pushHistory(); scheduleSave(); });

saveBtn.addEventListener('click', saveToLocal);
loadBtn.addEventListener('click', loadFromLocal);
exportJsonBtn.addEventListener('click', exportJSON);
exportImageBtn.addEventListener('click', exportBoardAsPNG);

/* link color swatches */
violetSw.addEventListener('click', ()=> { config.linkColor = getComputedStyle(document.documentElement).getPropertyValue('--neon-violet').trim(); redrawLinks(); });
greenSw.addEventListener('click', ()=> { config.linkColor = getComputedStyle(document.documentElement).getPropertyValue('--neon-green').trim(); redrawLinks(); });

toggleGrid.addEventListener('change', drawGrid);
toggleSnap.addEventListener('change', ()=> { config.snap = toggleSnap.checked; });

minWControl.addEventListener('input', ()=> { config.minW = parseInt(minWControl.value); $$('.node').forEach(n=> n.style.minWidth = config.minW+'px'); });
maxWControl.addEventListener('input', ()=> { config.maxW = parseInt(maxWControl.value); $$('.node').forEach(n=> n.style.maxWidth = config.maxW+'px'); });

/* board click to cancel connect and hide neon box */
board.addEventListener('click', (e)=> {
  if(mode==='connect'){ connectFrom = null; clearHighlights(); }
  // clear selection if click empty area (without ctrl)
  if(!e.ctrlKey && !e.metaKey){
    clearSelection();
  }
});

/* window resize redraw */
window.addEventListener('resize', () => { redrawLinks(); drawGrid(); });

/* show neon box when phrase present */
function showNeon(text, color){
  neonBox.textContent = text || '';
  document.documentElement.style.setProperty('--neon-violet', color || '#aa00ff');
  document.querySelector('.neon-wrap').classList.add('neon-active');
  setTimeout(()=> document.querySelector('.neon-wrap').classList.remove('neon-active'), 2200);
}

/* ----------------- MODES ----------------- */
function toggleMode(m) {
  mode = (mode === m ? null : m);
  if(mode !== 'connect') connectFrom = null;
  updateButtonsUI();
}
function updateButtonsUI() {
  connectModeBtn.classList.toggle('active', mode==='connect');
  connectModeBtn.classList.toggle('connect', mode==='connect');
  deleteModeBtn.classList.toggle('active', mode==='delete');
  deleteModeBtn.classList.toggle('delete', mode==='delete');
}

/* ----------------- SELECTION BOX (drag) ----------------- */
board.addEventListener('pointerdown', (e)=>{
  // only start selection when clicking on empty board area (not on node)
  if(e.target !== board && e.target.closest('.node')) return;
  if(e.button !== 0) return; // left only
  isSelecting = true;
  selectStart = { x: e.clientX, y: e.clientY };
  const br = board.getBoundingClientRect();
  selectionRect.style.left = (selectStart.x - br.left) + 'px';
  selectionRect.style.top = (selectStart.y - br.top) + 'px';
  selectionRect.style.width = '0px';
  selectionRect.style.height = '0px';
  selectionRect.style.display = 'block';
});

window.addEventListener('pointermove', (e)=>{
  if(!isSelecting) return;
  const br = board.getBoundingClientRect();
  const x = Math.min(e.clientX, selectStart.x);
  const y = Math.min(e.clientY, selectStart.y);
  const w = Math.abs(e.clientX - selectStart.x);
  const h = Math.abs(e.clientY - selectStart.y);
  selectionRect.style.left = (x - br.left) + 'px';
  selectionRect.style.top = (y - br.top) + 'px';
  selectionRect.style.width = w + 'px';
  selectionRect.style.height = h + 'px';

  // update selection of nodes
  $$('.node').forEach(n => {
    const r = n.getBoundingClientRect();
    const sel = !(r.right < x || r.left > x + w || r.bottom < y || r.top > y + h);
    if(sel) setSelected(n.dataset.id, true);
    else if(!(event.ctrlKey||event.metaKey)) setSelected(n.dataset.id, false);
  });
});

window.addEventListener('pointerup', (e)=>{
  if(isSelecting){
    isSelecting = false;
    selectionRect.style.display = 'none';
    pushHistory();
    scheduleSave();
  }
});

/* ----------------- ZOOM WITH WHEEL ----------------- */
board.addEventListener('wheel', (e)=>{
  // hold ctrl? still zoom; otherwise zoom with wheel (no page scroll)
  e.preventDefault();
  const delta = -e.deltaY;
  const factor = delta > 0 ? 1.08 : 0.92;
  const newScale = Math.max(0.25, Math.min(3, scale * factor));

  // apply zoom centered around mouse
  const rect = board.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  // compute origin shift to keep point under cursor
  const ox = mx / scale;
  const oy = my / scale;

  scale = newScale;
  boardInner.style.transform = `scale(${scale})`;

  // after scaling, adjust scroll-like translate to keep view ‚Äî we don't have pan, so not moving container
  redrawLinks();
  drawGrid();
}, { passive:false });

/* ----------------- DUPLICATE (Ctrl/Cmd + D) ----------------- */
window.addEventListener('keydown', (e)=>{
  if((e.key === 'd' || e.key === 'D') && (e.ctrlKey || e.metaKey)){
    e.preventDefault();
    duplicateSelected();
  }
});
function duplicateSelected(){
  const toDuplicate = Array.from(selectedIds);
  clearSelection();
  toDuplicate.forEach(id=>{
    const orig = state.nodes.find(n=>n.id===id);
    if(!orig) return;
    const copy = Object.assign({}, orig, { id: uid('n'), x: orig.x + 20, y: orig.y + 20 });
    state.nodes.push(copy);
    const dom = createNodeDOM(copy);
    nodesEl.appendChild(dom);
    setSelected(copy.id, true);
  });
  pushHistory();
  scheduleSave();
  redrawLinks();
}

/* ----------------- BOOT / INIT ----------------- */
function boot(){
  const raw = localStorage.getItem('visionboard_v3');
  if(raw){
    try{ loadState(JSON.parse(raw), true); showNeon('Tablero cargado (local)'); return; }catch(e){}
  }
  initialState();
  drawGrid();
}
boot();

/* expose some helpers to console for debugging */
window.__vision = { state, addNode, saveToLocal, loadFromLocal, exportJSON, loadState };

/* periodically redraw links for fluid bezier movement */
(function animate(){
  requestAnimationFrame(()=>{
    redrawLinks();
    requestAnimationFrame(animate);
  });
})();
</script>
</body>
</html>
